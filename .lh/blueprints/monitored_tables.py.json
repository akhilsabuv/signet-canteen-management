{
    "sourceFile": "blueprints/monitored_tables.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1740386483791,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1740388218377,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -451,5 +451,6 @@\n def update_monitored_counts_route():\r\n     if not session.get('logged_in'):\r\n         return redirect(url_for('auth.login'))\r\n     result = update_monitored_table_counts()\r\n-    return jsonify(result)\n\\ No newline at end of file\n+    return jsonify(result)\r\n+\r\n"
                },
                {
                    "date": 1740388228681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -453,4 +453,47 @@\n         return redirect(url_for('auth.login'))\r\n     result = update_monitored_table_counts()\r\n     return jsonify(result)\r\n \r\n+\r\n+###############################################\r\n+# Token Printing Functions\r\n+###############################################\r\n+def print_canteen_token(user_id, meal_name, meal_time):\r\n+    \"\"\"\r\n+    Prints the canteen token using the printer saved in the configuration file.\r\n+    The token includes \"CANTEEN TOKEN\", User ID, Meal, and Time.\r\n+    \"\"\"\r\n+    try:\r\n+        CONFIG_FILE = \"config.json\"\r\n+        from utils import load_config, log_event\r\n+        config = load_config(CONFIG_FILE)\r\n+        printer_name = config.get(\"selected_printer\", win32print.GetDefaultPrinter())\r\n+\r\n+        hprinter = win32ui.CreateDC()\r\n+        hprinter.CreatePrinterDC(printer_name)\r\n+        hprinter.StartDoc(\"Canteen Token\")\r\n+        hprinter.StartPage()\r\n+\r\n+        hprinter.TextOut(100, 100, \"CANTEEN TOKEN\")\r\n+        hprinter.TextOut(100, 150, f\"User ID: {user_id}\")\r\n+        hprinter.TextOut(100, 200, f\"Meal: {meal_name}\")\r\n+        hprinter.TextOut(100, 250, f\"Time: {meal_time}\")\r\n+\r\n+        hprinter.EndPage()\r\n+        hprinter.EndDoc()\r\n+        hprinter.DeleteDC()\r\n+\r\n+        log_event(f\"Token Printed: User {user_id} | {meal_name} | {meal_time}\")\r\n+    except Exception as e:\r\n+        from utils import log_event\r\n+        log_event(f\"Printing Error: {e}\")\r\n+\r\n+def process_event_and_print_token(user_id, meal_name, meal_time, eligibility):\r\n+    \"\"\"\r\n+    Checks eligibility and prints token if eligible.\r\n+    \"\"\"\r\n+    if eligibility:\r\n+        print(\"User is eligible. Printing token...\")\r\n+        print_canteen_token(user_id, meal_name, meal_time)\r\n+    else:\r\n+        print(\"User is not eligible. Token will not be printed.\")\r\n"
                },
                {
                    "date": 1740388238289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -453,47 +453,4 @@\n         return redirect(url_for('auth.login'))\r\n     result = update_monitored_table_counts()\r\n     return jsonify(result)\r\n \r\n-\r\n-###############################################\r\n-# Token Printing Functions\r\n-###############################################\r\n-def print_canteen_token(user_id, meal_name, meal_time):\r\n-    \"\"\"\r\n-    Prints the canteen token using the printer saved in the configuration file.\r\n-    The token includes \"CANTEEN TOKEN\", User ID, Meal, and Time.\r\n-    \"\"\"\r\n-    try:\r\n-        CONFIG_FILE = \"config.json\"\r\n-        from utils import load_config, log_event\r\n-        config = load_config(CONFIG_FILE)\r\n-        printer_name = config.get(\"selected_printer\", win32print.GetDefaultPrinter())\r\n-\r\n-        hprinter = win32ui.CreateDC()\r\n-        hprinter.CreatePrinterDC(printer_name)\r\n-        hprinter.StartDoc(\"Canteen Token\")\r\n-        hprinter.StartPage()\r\n-\r\n-        hprinter.TextOut(100, 100, \"CANTEEN TOKEN\")\r\n-        hprinter.TextOut(100, 150, f\"User ID: {user_id}\")\r\n-        hprinter.TextOut(100, 200, f\"Meal: {meal_name}\")\r\n-        hprinter.TextOut(100, 250, f\"Time: {meal_time}\")\r\n-\r\n-        hprinter.EndPage()\r\n-        hprinter.EndDoc()\r\n-        hprinter.DeleteDC()\r\n-\r\n-        log_event(f\"Token Printed: User {user_id} | {meal_name} | {meal_time}\")\r\n-    except Exception as e:\r\n-        from utils import log_event\r\n-        log_event(f\"Printing Error: {e}\")\r\n-\r\n-def process_event_and_print_token(user_id, meal_name, meal_time, eligibility):\r\n-    \"\"\"\r\n-    Checks eligibility and prints token if eligible.\r\n-    \"\"\"\r\n-    if eligibility:\r\n-        print(\"User is eligible. Printing token...\")\r\n-        print_canteen_token(user_id, meal_name, meal_time)\r\n-    else:\r\n-        print(\"User is not eligible. Token will not be printed.\")\r\n"
                },
                {
                    "date": 1740388403593,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -436,8 +436,43 @@\n         return {\"error\": str(e)}\r\n     finally:\r\n         conn.close()\r\n \r\n+\r\n+\r\n+def print_canteen_token(user_id, meal_name, meal_time):\r\n+    \"\"\"\r\n+    Enhanced token printing with error handling and formatting\r\n+    \"\"\"\r\n+    try:\r\n+        CONFIG_FILE = \"config.json\"\r\n+        from utils import load_config, log_event, print_token, validate_printer\r\n+        \r\n+        # Load configuration\r\n+        config = load_config(CONFIG_FILE)\r\n+        printer_name = config.get(\"selected_printer\", win32print.GetDefaultPrinter())\r\n+\r\n+        # Validate printer\r\n+        if not validate_printer(printer_name):\r\n+            log_event(f\"Invalid printer: {printer_name}\")\r\n+            return False\r\n+\r\n+        # Print token\r\n+        success = print_token(printer_name, user_id, meal_name, meal_time)\r\n+        \r\n+        if success:\r\n+            log_event(f\"Token Printed Successfully - User: {user_id} | {meal_name} | {meal_time}\")\r\n+        else:\r\n+            log_event(f\"Token Printing Failed - User: {user_id} | {meal_name} | {meal_time}\")\r\n+        \r\n+        return success\r\n+\r\n+    except Exception as e:\r\n+        log_event(f\"Token Printing Error: {str(e)}\")\r\n+        print(f\"Error printing token: {str(e)}\")\r\n+        return False\r\n+    \r\n+    \r\n ###############################################\r\n # Route Endpoints\r\n ###############################################\r\n @monitored_tables_bp.route('/monitored-tables', methods=['GET'])\r\n"
                },
                {
                    "date": 1740388420616,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -436,10 +436,13 @@\n         return {\"error\": str(e)}\r\n     finally:\r\n         conn.close()\r\n \r\n+    \r\n+###############################################\r\n+# Print Token   Helpers\r\n+###############################################\r\n \r\n-\r\n def print_canteen_token(user_id, meal_name, meal_time):\r\n     \"\"\"\r\n     Enhanced token printing with error handling and formatting\r\n     \"\"\"\r\n"
                },
                {
                    "date": 1740388434574,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,495 @@\n+import re\r\n+import datetime\r\n+import pytz\r\n+import pyodbc\r\n+from flask import Blueprint, jsonify, current_app, session, redirect, url_for\r\n+import win32print\r\n+\r\n+monitored_tables_bp = Blueprint('monitored_tables', __name__, url_prefix='/dashboard')\r\n+\r\n+# Global variable to store previous row counts for monitored tables\r\n+previous_monitored_counts = {}\r\n+\r\n+###############################################\r\n+# MAIN_DB Monitored Tables Query\r\n+###############################################\r\n+def get_main_db_monitored_tables():\r\n+    \"\"\"\r\n+    Queries the MAIN_DB for tables whose names match TABLE_PREFIX followed by exactly six digits.\r\n+    Returns a list of dictionaries with table_name and row_count.\r\n+    \"\"\"\r\n+    config = current_app.config\r\n+    host = config.get('MAIN_DB_HOST')\r\n+    username = config.get('MAIN_DB_USERNAME')\r\n+    password = config.get('MAIN_DB_PASSWORD')\r\n+    dbname = config.get('MAIN_DB_NAME')\r\n+    table_prefix = config.get('TABLE_PREFIX', 't_lg')\r\n+    \r\n+    # Build connection string for MAIN_DB (omit port if not needed)\r\n+    conn_str = (\r\n+        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n+        f\"SERVER={host};\"\r\n+        f\"DATABASE={dbname};\"\r\n+        f\"UID={username};PWD={password}\"\r\n+    )\r\n+    \r\n+    # Build SQL pattern: TABLE_PREFIX followed by exactly six digits.\r\n+    pattern = table_prefix + \"[0-9][0-9][0-9][0-9][0-9][0-9]\"\r\n+    \r\n+    query = \"\"\"\r\n+        SELECT t.name AS table_name, SUM(p.rows) AS row_count\r\n+        FROM sys.tables t\r\n+        INNER JOIN sys.partitions p ON t.object_id = p.object_id\r\n+        WHERE t.name LIKE ? AND p.index_id < 2\r\n+        GROUP BY t.name\r\n+        ORDER BY t.name;\r\n+    \"\"\"\r\n+    \r\n+    try:\r\n+        conn = pyodbc.connect(conn_str, timeout=5)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(query, (pattern,))\r\n+        results = []\r\n+        for row in cursor.fetchall():\r\n+            results.append({\r\n+                \"table_name\": row.table_name,\r\n+                \"row_count\": row.row_count\r\n+            })\r\n+        conn.close()\r\n+        return results\r\n+    except Exception as e:\r\n+        print(\"Error retrieving monitored tables from MAIN_DB:\", e)\r\n+        return []\r\n+\r\n+###############################################\r\n+# LOGGER_DB Connection Helper\r\n+###############################################\r\n+def get_logger_db_conn():\r\n+    \"\"\"\r\n+    Returns a pyodbc connection to LOGGER_DB using current_app.config values.\r\n+    \"\"\"\r\n+    config = current_app.config\r\n+    host = config.get('LOGGER_DB_HOST')\r\n+    username = config.get('LOGGER_DB_USERNAME')\r\n+    password = config.get('LOGGER_DB_PASSWORD')\r\n+    dbname = config.get('LOGGER_DB_NAME')\r\n+    conn_str = (\r\n+        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n+        f\"SERVER={host};\"\r\n+        f\"DATABASE={dbname};\"\r\n+        f\"UID={username};PWD={password}\"\r\n+    )\r\n+    return pyodbc.connect(conn_str, timeout=5)\r\n+\r\n+###############################################\r\n+# Device Registration Helpers\r\n+###############################################\r\n+def get_canteen_device_ids():\r\n+    \"\"\"\r\n+    Retrieve all 'devid' values from LOGGER_DB's sig_devices table where device_type = 'canteen'.\r\n+    Returns a set of devid values as strings.\r\n+    \"\"\"\r\n+    device_ids = set()\r\n+    try:\r\n+        conn = get_logger_db_conn()\r\n+        cursor = conn.cursor()\r\n+        query = \"SELECT devid FROM sig_devices WHERE device_type = 'canteen'\"\r\n+        cursor.execute(query)\r\n+        for row in cursor.fetchall():\r\n+            device_ids.add(str(row.devid))\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        print(\"Error retrieving canteen device IDs:\", e)\r\n+    return device_ids\r\n+\r\n+def get_entry_device_ids():\r\n+    \"\"\"\r\n+    Retrieve all 'devid' values from LOGGER_DB's sig_devices table where device_type = 'entry'.\r\n+    Returns a set of devid values as strings.\r\n+    \"\"\"\r\n+    device_ids = set()\r\n+    try:\r\n+        conn = get_logger_db_conn()\r\n+        cursor = conn.cursor()\r\n+        query = \"SELECT devid FROM sig_devices WHERE device_type = 'entry'\"\r\n+        cursor.execute(query)\r\n+        for row in cursor.fetchall():\r\n+            device_ids.add(str(row.devid))\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        print(\"Error retrieving entry device IDs:\", e)\r\n+    return device_ids\r\n+\r\n+###############################################\r\n+# Candidate Generation Helper\r\n+###############################################\r\n+def get_closest_candidate(event_local, shift_time, tz, delta_range=(-1, 0, 1)):\r\n+    \"\"\"\r\n+    Given an event's local datetime (event_local) and a shift start time (a TIME object),\r\n+    generate candidate datetimes by combining shift_time with event_local's date offset by each delta in delta_range.\r\n+    Returns the candidate datetime that minimizes the absolute difference from event_local.\r\n+    \"\"\"\r\n+    candidates = []\r\n+    for delta in delta_range:\r\n+        candidate_date = event_local.date() + datetime.timedelta(days=delta)\r\n+        candidate_naive = datetime.datetime.combine(candidate_date, shift_time)\r\n+        candidate_dt = tz.localize(candidate_naive)\r\n+        candidates.append(candidate_dt)\r\n+    best = min(candidates, key=lambda d: abs((event_local - d).total_seconds()))\r\n+    return best\r\n+\r\n+###############################################\r\n+# Latest Attendance Event Retrieval\r\n+###############################################\r\n+def get_latest_entry_event_time(usrid):\r\n+    \"\"\"\r\n+    Retrieves the latest attendance event time (SRVDT) for the given user (USRID)\r\n+    by searching all MAIN_DB tables whose name matches TABLE_PREFIX + 6 digits,\r\n+    and where DEVUID is in the entry device list.\r\n+    \r\n+    Returns a timezone-aware datetime in the configured TIME_ZONE, or None if no event is found.\r\n+    \"\"\"\r\n+    config = current_app.config\r\n+    table_prefix = config.get('TABLE_PREFIX', 't_lg')\r\n+    main_host = config.get('MAIN_DB_HOST')\r\n+    main_username = config.get('MAIN_DB_USERNAME')\r\n+    main_password = config.get('MAIN_DB_PASSWORD')\r\n+    main_dbname = config.get('MAIN_DB_NAME')\r\n+    \r\n+    conn_str = (\r\n+        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n+        f\"SERVER={main_host};\"\r\n+        f\"DATABASE={main_dbname};\"\r\n+        f\"UID={main_username};PWD={main_password}\"\r\n+    )\r\n+    \r\n+    table_regex = re.compile(f\"^{re.escape(table_prefix)}\\\\d{{6}}$\")\r\n+    latest_event = None\r\n+    try:\r\n+        conn = pyodbc.connect(conn_str, timeout=5)\r\n+        cursor = conn.cursor()\r\n+        cursor.execute(\"SELECT name FROM sys.tables WHERE name LIKE ?\", (table_prefix + '%',))\r\n+        tables = [row.name for row in cursor.fetchall() if table_regex.match(row.name)]\r\n+        \r\n+        entry_ids = get_entry_device_ids()\r\n+        if not entry_ids:\r\n+            print(\"No entry device IDs found.\")\r\n+            conn.close()\r\n+            return None\r\n+        \r\n+        in_clause = \",\".join(\"?\" for _ in entry_ids)\r\n+        \r\n+        for table in tables:\r\n+            query = f\"\"\"\r\n+                SELECT TOP 1 SRVDT \r\n+                FROM {table}\r\n+                WHERE USRID = ? AND CAST(DEVUID AS VARCHAR(50)) IN ({in_clause})\r\n+                ORDER BY SRVDT DESC\r\n+            \"\"\"\r\n+            params = [usrid] + list(entry_ids)\r\n+            try:\r\n+                cursor.execute(query, params)\r\n+                row = cursor.fetchone()\r\n+                if row:\r\n+                    event_time = row.SRVDT\r\n+                    if event_time.tzinfo is None:\r\n+                        event_time = pytz.utc.localize(event_time)\r\n+                    if (latest_event is None) or (event_time > latest_event):\r\n+                        latest_event = event_time\r\n+            except Exception as ex:\r\n+                print(f\"Error querying table {table}: {ex}\")\r\n+                continue\r\n+        conn.close()\r\n+        \r\n+        if latest_event:\r\n+            tz_config = pytz.timezone(config.get(\"TIME_ZONE\", \"UTC\"))\r\n+            latest_event = latest_event.astimezone(tz_config)\r\n+        return latest_event\r\n+    except Exception as e:\r\n+        print(\"Error retrieving latest entry event time:\", e)\r\n+        return None\r\n+\r\n+###############################################\r\n+# Canteen Eligibility Checker\r\n+###############################################\r\n+def check_elegibility(event_dt, devuid, usrid):\r\n+    \"\"\"\r\n+    Dynamic meal time eligibility checker that adapts to any changes in canteen_timings table\r\n+    \"\"\"\r\n+    print(f\"Checking canteen timing eligibility for event: DEVUID={devuid}, USRID={usrid}, Event Time={event_dt}\")\r\n+    config = current_app.config\r\n+    tz = pytz.timezone(config.get(\"TIME_ZONE\", \"UTC\"))\r\n+    event_local = event_dt.astimezone(tz)\r\n+    print(f\"Event local time for eligibility: {event_local}\")\r\n+    \r\n+    eligible = False\r\n+    trigger = None\r\n+    \r\n+    try:\r\n+        conn = get_logger_db_conn()\r\n+        cursor = conn.cursor()\r\n+        \r\n+        # Always gets fresh timing data from database\r\n+        # If meal times are changed in database, this will automatically use new timings\r\n+        cursor.execute(\"\"\"\r\n+            SELECT \r\n+                canteen_name,\r\n+                start_time,\r\n+                end_time,\r\n+                created_at\r\n+            FROM canteen_timings \r\n+            WHERE start_time <= CAST(GETDATE() AS TIME)\r\n+            AND end_time >= CAST(GETDATE() AS TIME)\r\n+            ORDER BY start_time\r\n+        \"\"\")\r\n+        \r\n+        event_time = event_local.time()\r\n+        \r\n+        for row in cursor.fetchall():\r\n+            start_time = row.start_time\r\n+            end_time = row.end_time\r\n+            \r\n+            print(f\"Checking {row.canteen_name}: {start_time} - {end_time}\")\r\n+            print(f\"Current event time: {event_time}\")\r\n+            \r\n+            # Dynamic time window check\r\n+            if start_time <= event_time <= end_time:\r\n+                eligible = True\r\n+                trigger = (f\"Canteen: {row.canteen_name} \"\r\n+                         f\"({start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')})\")\r\n+                print(f\"Match found: {trigger}\")\r\n+                break\r\n+        \r\n+        conn.close()\r\n+        \r\n+    except Exception as e:\r\n+        print(\"Error checking canteen eligibility:\", e)\r\n+        return False\r\n+    \r\n+    if eligible:\r\n+        print(f\"Timing eligibility met based on {trigger}\")\r\n+    else:\r\n+        print(\"No eligible timing found\")\r\n+    \r\n+    return eligible\r\n+\r\n+###############################################\r\n+# Row Count Change & Overall Eligibility Check\r\n+###############################################\r\n+def row_count_change(table_name, previous_count, new_count):\r\n+    \"\"\"\r\n+    Triggered when a monitored table's row count changes.\r\n+    \r\n+    Retrieves the latest event from the MAIN_DB monitored table (TABLE_PREFIX + 6 digits).\r\n+    Checks if the event's DEVUID is registered as a canteen device or an entry device.\r\n+      - If canteen device: \r\n+          * Checks canteen timing eligibility using check_elegibility().\r\n+          * If eligible, retrieves the latest attendance event for the user.\r\n+          * Computes allowed deadline = SHIFT_START_TIME + ATTENDANCE_BUFFER_MINUTES.\r\n+          * If the attendance event occurred before the deadline, returns True; otherwise, False.\r\n+      - If entry device: automatically eligible.\r\n+      - Otherwise: automatically eligible.\r\n+    \"\"\"\r\n+    print(f\"Row count changed for {table_name}: from {previous_count} to {new_count}\")\r\n+    config = current_app.config\r\n+    host = config.get(\"MAIN_DB_HOST\")\r\n+    username = config.get(\"MAIN_DB_USERNAME\")\r\n+    password = config.get(\"MAIN_DB_PASSWORD\")\r\n+    dbname = config.get(\"MAIN_DB_NAME\")\r\n+    tz = pytz.timezone(config.get(\"TIME_ZONE\", \"UTC\"))\r\n+    \r\n+    conn_str = (\r\n+        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n+        f\"SERVER={host};\"\r\n+        f\"DATABASE={dbname};\"\r\n+        f\"UID={username};PWD={password}\"\r\n+    )\r\n+    \r\n+    try:\r\n+        conn = pyodbc.connect(conn_str, timeout=5)\r\n+        cursor = conn.cursor()\r\n+        query = f\"SELECT TOP 1 DEVDT, DEVUID, USRID FROM {table_name} ORDER BY SRVDT DESC\"\r\n+        cursor.execute(query)\r\n+        row = cursor.fetchone()\r\n+        if row:\r\n+            # Convert DEVDT if it's a Unix timestamp.\r\n+            event_dt = row.DEVDT\r\n+            if isinstance(event_dt, (int, float)):\r\n+                event_dt = datetime.datetime.fromtimestamp(event_dt, tz=pytz.utc)\r\n+            print(f\"Latest event in {table_name}: DEVDT={event_dt}, DEVUID={row.DEVUID}, USRID={row.USRID}\")\r\n+            event_devid = str(row.DEVUID)\r\n+            event_local = event_dt.astimezone(tz)\r\n+            print(f\"Event local time: {event_local}\")\r\n+            \r\n+            # Retrieve dynamic device lists.\r\n+            canteen_ids = get_canteen_device_ids()\r\n+            entry_ids = get_entry_device_ids()\r\n+            \r\n+            if event_devid in canteen_ids:\r\n+                print(\"Device is registered as a canteen device. Checking canteen eligibility...\")\r\n+                if not check_elegibility(event_dt, row.DEVUID, row.USRID):\r\n+                    print(\"Canteen timing conditions not met; not eligible.\")\r\n+                    return False\r\n+                else:\r\n+                    print(\"Canteen timing conditions met.\")\r\n+                    latest_entry = get_latest_entry_event_time(row.USRID)\r\n+                    if latest_entry is None:\r\n+                        print(\"No attendance event found; not eligible.\")\r\n+                        return False\r\n+                    shift_start_str = config.get(\"SHIFT_START_TIME\", \"01:00\")\r\n+                    attendance_buffer = config.get(\"ATTENDANCE_BUFFER_MINUTES\", 60)\r\n+                    try:\r\n+                        shift_start_time = datetime.datetime.strptime(shift_start_str, \"%H:%M\").time()\r\n+                    except Exception as e:\r\n+                        print(\"Error parsing SHIFT_START_TIME:\", e)\r\n+                        return False\r\n+                    allowed_deadline = datetime.datetime.combine(event_local.date(), shift_start_time) + datetime.timedelta(minutes=attendance_buffer)\r\n+                    allowed_deadline = tz.localize(allowed_deadline)\r\n+                    print(f\"Allowed attendance deadline: {allowed_deadline}\")\r\n+                    print(f\"Latest attendance event: {latest_entry}\")\r\n+                    \r\n+                    if latest_entry <= allowed_deadline:\r\n+                        print(\"Attendance event is within allowed buffer; eligible for canteen service.\")\r\n+                        return True\r\n+                    else:\r\n+                        print(\"Attendance event is too late; not eligible.\")\r\n+                        return False\r\n+            elif event_devid in entry_ids:\r\n+                print(\"Device is registered as an entry device; automatically eligible.\")\r\n+                return True\r\n+            else:\r\n+                print(\"Device not registered as canteen or entry; automatically eligible.\")\r\n+                return True\r\n+        else:\r\n+            print(f\"No event details found in {table_name}.\")\r\n+            return False\r\n+        conn.close()\r\n+    except Exception as e:\r\n+        print(f\"Error retrieving event details from {table_name}: {e}\")\r\n+        return False\r\n+\r\n+###############################################\r\n+# Monitored Counts Table Update\r\n+###############################################\r\n+def ensure_monitored_counts_table():\r\n+    \"\"\"\r\n+    Ensure that the monitored_table_counts table exists in LOGGER_DB.\r\n+    This table stores the monitored table name, row count, and timestamp.\r\n+    \"\"\"\r\n+    conn = get_logger_db_conn()\r\n+    cursor = conn.cursor()\r\n+    create_table_sql = \"\"\"\r\n+    IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'monitored_table_counts')\r\n+    BEGIN\r\n+        CREATE TABLE monitored_table_counts (\r\n+            id INT IDENTITY(1,1) PRIMARY KEY,\r\n+            table_name VARCHAR(100) NOT NULL,\r\n+            row_count BIGINT NOT NULL,\r\n+            updated_at DATETIME DEFAULT GETDATE()\r\n+        );\r\n+    END\r\n+    \"\"\"\r\n+    try:\r\n+        cursor.execute(create_table_sql)\r\n+        conn.commit()\r\n+    except Exception as e:\r\n+        print(\"Error ensuring monitored_table_counts table:\", e)\r\n+    finally:\r\n+        conn.close()\r\n+\r\n+def update_monitored_table_counts():\r\n+    \"\"\"\r\n+    Retrieves monitored table row counts from MAIN_DB and saves them to LOGGER_DB.\r\n+    Clears the monitored_table_counts table first, then inserts fresh data.\r\n+    For any table with a changed row count (compared to the previous snapshot),\r\n+    calls row_count_change() to process the event.\r\n+    \"\"\"\r\n+    global previous_monitored_counts\r\n+    monitored_tables = get_main_db_monitored_tables()\r\n+    if not monitored_tables:\r\n+        print(\"No monitored tables data retrieved.\")\r\n+        return {\"error\": \"No data retrieved\"}\r\n+    \r\n+    # Check for row count changes.\r\n+    for entry in monitored_tables:\r\n+        table_name = entry[\"table_name\"]\r\n+        new_count = entry[\"row_count\"]\r\n+        previous_count = previous_monitored_counts.get(table_name)\r\n+        if previous_count is None or previous_count != new_count:\r\n+            row_count_change(table_name, previous_count, new_count)\r\n+    previous_monitored_counts = {entry[\"table_name\"]: entry[\"row_count\"] for entry in monitored_tables}\r\n+    \r\n+    ensure_monitored_counts_table()\r\n+    conn = get_logger_db_conn()\r\n+    cursor = conn.cursor()\r\n+    try:\r\n+        cursor.execute(\"DELETE FROM monitored_table_counts\")\r\n+        insert_sql = \"\"\"\r\n+            INSERT INTO monitored_table_counts (table_name, row_count)\r\n+            VALUES (?, ?)\r\n+        \"\"\"\r\n+        for entry in monitored_tables:\r\n+            cursor.execute(insert_sql, (entry[\"table_name\"], entry[\"row_count\"]))\r\n+        conn.commit()\r\n+        return {\"status\": \"success\", \"data\": monitored_tables}\r\n+    except Exception as e:\r\n+        print(\"Error updating monitored_table_counts:\", e)\r\n+        return {\"error\": str(e)}\r\n+    finally:\r\n+        conn.close()\r\n+\r\n+    \r\n+###############################################\r\n+# Print Token Helpers\r\n+###############################################\r\n+\r\n+def print_canteen_token(user_id, meal_name, meal_time):\r\n+    \"\"\"\r\n+    Enhanced token printing with error handling and formatting\r\n+    \"\"\"\r\n+    try:\r\n+        CONFIG_FILE = \"config.json\"\r\n+        from utils import load_config, log_event, print_token, validate_printer\r\n+        \r\n+        # Load configuration\r\n+        config = load_config(CONFIG_FILE)\r\n+        printer_name = config.get(\"selected_printer\", win32print.GetDefaultPrinter())\r\n+\r\n+        # Validate printer\r\n+        if not validate_printer(printer_name):\r\n+            log_event(f\"Invalid printer: {printer_name}\")\r\n+            return False\r\n+\r\n+        # Print token\r\n+        success = print_token(printer_name, user_id, meal_name, meal_time)\r\n+        \r\n+        if success:\r\n+            log_event(f\"Token Printed Successfully - User: {user_id} | {meal_name} | {meal_time}\")\r\n+        else:\r\n+            log_event(f\"Token Printing Failed - User: {user_id} | {meal_name} | {meal_time}\")\r\n+        \r\n+        return success\r\n+\r\n+    except Exception as e:\r\n+        log_event(f\"Token Printing Error: {str(e)}\")\r\n+        print(f\"Error printing token: {str(e)}\")\r\n+        return False\r\n+    \r\n+    \r\n+###############################################\r\n+# Route Endpoints\r\n+###############################################\r\n+@monitored_tables_bp.route('/monitored-tables', methods=['GET'])\r\n+def get_monitored_tables_route():\r\n+    if not session.get('logged_in'):\r\n+        return redirect(url_for('auth.login'))\r\n+    monitored = get_main_db_monitored_tables()\r\n+    return jsonify(monitored)\r\n+\r\n+@monitored_tables_bp.route('/update_monitored_counts', methods=['GET'])\r\n+def update_monitored_counts_route():\r\n+    if not session.get('logged_in'):\r\n+        return redirect(url_for('auth.login'))\r\n+    result = update_monitored_table_counts()\r\n+    return jsonify(result)\r\n+\r\n"
                }
            ],
            "date": 1740386483791,
            "name": "Commit-0",
            "content": "import re\r\nimport datetime\r\nimport pytz\r\nimport pyodbc\r\nfrom flask import Blueprint, jsonify, current_app, session, redirect, url_for\r\n\r\nmonitored_tables_bp = Blueprint('monitored_tables', __name__, url_prefix='/dashboard')\r\n\r\n# Global variable to store previous row counts for monitored tables\r\nprevious_monitored_counts = {}\r\n\r\n###############################################\r\n# MAIN_DB Monitored Tables Query\r\n###############################################\r\ndef get_main_db_monitored_tables():\r\n    \"\"\"\r\n    Queries the MAIN_DB for tables whose names match TABLE_PREFIX followed by exactly six digits.\r\n    Returns a list of dictionaries with table_name and row_count.\r\n    \"\"\"\r\n    config = current_app.config\r\n    host = config.get('MAIN_DB_HOST')\r\n    username = config.get('MAIN_DB_USERNAME')\r\n    password = config.get('MAIN_DB_PASSWORD')\r\n    dbname = config.get('MAIN_DB_NAME')\r\n    table_prefix = config.get('TABLE_PREFIX', 't_lg')\r\n    \r\n    # Build connection string for MAIN_DB (omit port if not needed)\r\n    conn_str = (\r\n        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n        f\"SERVER={host};\"\r\n        f\"DATABASE={dbname};\"\r\n        f\"UID={username};PWD={password}\"\r\n    )\r\n    \r\n    # Build SQL pattern: TABLE_PREFIX followed by exactly six digits.\r\n    pattern = table_prefix + \"[0-9][0-9][0-9][0-9][0-9][0-9]\"\r\n    \r\n    query = \"\"\"\r\n        SELECT t.name AS table_name, SUM(p.rows) AS row_count\r\n        FROM sys.tables t\r\n        INNER JOIN sys.partitions p ON t.object_id = p.object_id\r\n        WHERE t.name LIKE ? AND p.index_id < 2\r\n        GROUP BY t.name\r\n        ORDER BY t.name;\r\n    \"\"\"\r\n    \r\n    try:\r\n        conn = pyodbc.connect(conn_str, timeout=5)\r\n        cursor = conn.cursor()\r\n        cursor.execute(query, (pattern,))\r\n        results = []\r\n        for row in cursor.fetchall():\r\n            results.append({\r\n                \"table_name\": row.table_name,\r\n                \"row_count\": row.row_count\r\n            })\r\n        conn.close()\r\n        return results\r\n    except Exception as e:\r\n        print(\"Error retrieving monitored tables from MAIN_DB:\", e)\r\n        return []\r\n\r\n###############################################\r\n# LOGGER_DB Connection Helper\r\n###############################################\r\ndef get_logger_db_conn():\r\n    \"\"\"\r\n    Returns a pyodbc connection to LOGGER_DB using current_app.config values.\r\n    \"\"\"\r\n    config = current_app.config\r\n    host = config.get('LOGGER_DB_HOST')\r\n    username = config.get('LOGGER_DB_USERNAME')\r\n    password = config.get('LOGGER_DB_PASSWORD')\r\n    dbname = config.get('LOGGER_DB_NAME')\r\n    conn_str = (\r\n        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n        f\"SERVER={host};\"\r\n        f\"DATABASE={dbname};\"\r\n        f\"UID={username};PWD={password}\"\r\n    )\r\n    return pyodbc.connect(conn_str, timeout=5)\r\n\r\n###############################################\r\n# Device Registration Helpers\r\n###############################################\r\ndef get_canteen_device_ids():\r\n    \"\"\"\r\n    Retrieve all 'devid' values from LOGGER_DB's sig_devices table where device_type = 'canteen'.\r\n    Returns a set of devid values as strings.\r\n    \"\"\"\r\n    device_ids = set()\r\n    try:\r\n        conn = get_logger_db_conn()\r\n        cursor = conn.cursor()\r\n        query = \"SELECT devid FROM sig_devices WHERE device_type = 'canteen'\"\r\n        cursor.execute(query)\r\n        for row in cursor.fetchall():\r\n            device_ids.add(str(row.devid))\r\n        conn.close()\r\n    except Exception as e:\r\n        print(\"Error retrieving canteen device IDs:\", e)\r\n    return device_ids\r\n\r\ndef get_entry_device_ids():\r\n    \"\"\"\r\n    Retrieve all 'devid' values from LOGGER_DB's sig_devices table where device_type = 'entry'.\r\n    Returns a set of devid values as strings.\r\n    \"\"\"\r\n    device_ids = set()\r\n    try:\r\n        conn = get_logger_db_conn()\r\n        cursor = conn.cursor()\r\n        query = \"SELECT devid FROM sig_devices WHERE device_type = 'entry'\"\r\n        cursor.execute(query)\r\n        for row in cursor.fetchall():\r\n            device_ids.add(str(row.devid))\r\n        conn.close()\r\n    except Exception as e:\r\n        print(\"Error retrieving entry device IDs:\", e)\r\n    return device_ids\r\n\r\n###############################################\r\n# Candidate Generation Helper\r\n###############################################\r\ndef get_closest_candidate(event_local, shift_time, tz, delta_range=(-1, 0, 1)):\r\n    \"\"\"\r\n    Given an event's local datetime (event_local) and a shift start time (a TIME object),\r\n    generate candidate datetimes by combining shift_time with event_local's date offset by each delta in delta_range.\r\n    Returns the candidate datetime that minimizes the absolute difference from event_local.\r\n    \"\"\"\r\n    candidates = []\r\n    for delta in delta_range:\r\n        candidate_date = event_local.date() + datetime.timedelta(days=delta)\r\n        candidate_naive = datetime.datetime.combine(candidate_date, shift_time)\r\n        candidate_dt = tz.localize(candidate_naive)\r\n        candidates.append(candidate_dt)\r\n    best = min(candidates, key=lambda d: abs((event_local - d).total_seconds()))\r\n    return best\r\n\r\n###############################################\r\n# Latest Attendance Event Retrieval\r\n###############################################\r\ndef get_latest_entry_event_time(usrid):\r\n    \"\"\"\r\n    Retrieves the latest attendance event time (SRVDT) for the given user (USRID)\r\n    by searching all MAIN_DB tables whose name matches TABLE_PREFIX + 6 digits,\r\n    and where DEVUID is in the entry device list.\r\n    \r\n    Returns a timezone-aware datetime in the configured TIME_ZONE, or None if no event is found.\r\n    \"\"\"\r\n    config = current_app.config\r\n    table_prefix = config.get('TABLE_PREFIX', 't_lg')\r\n    main_host = config.get('MAIN_DB_HOST')\r\n    main_username = config.get('MAIN_DB_USERNAME')\r\n    main_password = config.get('MAIN_DB_PASSWORD')\r\n    main_dbname = config.get('MAIN_DB_NAME')\r\n    \r\n    conn_str = (\r\n        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n        f\"SERVER={main_host};\"\r\n        f\"DATABASE={main_dbname};\"\r\n        f\"UID={main_username};PWD={main_password}\"\r\n    )\r\n    \r\n    table_regex = re.compile(f\"^{re.escape(table_prefix)}\\\\d{{6}}$\")\r\n    latest_event = None\r\n    try:\r\n        conn = pyodbc.connect(conn_str, timeout=5)\r\n        cursor = conn.cursor()\r\n        cursor.execute(\"SELECT name FROM sys.tables WHERE name LIKE ?\", (table_prefix + '%',))\r\n        tables = [row.name for row in cursor.fetchall() if table_regex.match(row.name)]\r\n        \r\n        entry_ids = get_entry_device_ids()\r\n        if not entry_ids:\r\n            print(\"No entry device IDs found.\")\r\n            conn.close()\r\n            return None\r\n        \r\n        in_clause = \",\".join(\"?\" for _ in entry_ids)\r\n        \r\n        for table in tables:\r\n            query = f\"\"\"\r\n                SELECT TOP 1 SRVDT \r\n                FROM {table}\r\n                WHERE USRID = ? AND CAST(DEVUID AS VARCHAR(50)) IN ({in_clause})\r\n                ORDER BY SRVDT DESC\r\n            \"\"\"\r\n            params = [usrid] + list(entry_ids)\r\n            try:\r\n                cursor.execute(query, params)\r\n                row = cursor.fetchone()\r\n                if row:\r\n                    event_time = row.SRVDT\r\n                    if event_time.tzinfo is None:\r\n                        event_time = pytz.utc.localize(event_time)\r\n                    if (latest_event is None) or (event_time > latest_event):\r\n                        latest_event = event_time\r\n            except Exception as ex:\r\n                print(f\"Error querying table {table}: {ex}\")\r\n                continue\r\n        conn.close()\r\n        \r\n        if latest_event:\r\n            tz_config = pytz.timezone(config.get(\"TIME_ZONE\", \"UTC\"))\r\n            latest_event = latest_event.astimezone(tz_config)\r\n        return latest_event\r\n    except Exception as e:\r\n        print(\"Error retrieving latest entry event time:\", e)\r\n        return None\r\n\r\n###############################################\r\n# Canteen Eligibility Checker\r\n###############################################\r\ndef check_elegibility(event_dt, devuid, usrid):\r\n    \"\"\"\r\n    Dynamic meal time eligibility checker that adapts to any changes in canteen_timings table\r\n    \"\"\"\r\n    print(f\"Checking canteen timing eligibility for event: DEVUID={devuid}, USRID={usrid}, Event Time={event_dt}\")\r\n    config = current_app.config\r\n    tz = pytz.timezone(config.get(\"TIME_ZONE\", \"UTC\"))\r\n    event_local = event_dt.astimezone(tz)\r\n    print(f\"Event local time for eligibility: {event_local}\")\r\n    \r\n    eligible = False\r\n    trigger = None\r\n    \r\n    try:\r\n        conn = get_logger_db_conn()\r\n        cursor = conn.cursor()\r\n        \r\n        # Always gets fresh timing data from database\r\n        # If meal times are changed in database, this will automatically use new timings\r\n        cursor.execute(\"\"\"\r\n            SELECT \r\n                canteen_name,\r\n                start_time,\r\n                end_time,\r\n                created_at\r\n            FROM canteen_timings \r\n            WHERE start_time <= CAST(GETDATE() AS TIME)\r\n            AND end_time >= CAST(GETDATE() AS TIME)\r\n            ORDER BY start_time\r\n        \"\"\")\r\n        \r\n        event_time = event_local.time()\r\n        \r\n        for row in cursor.fetchall():\r\n            start_time = row.start_time\r\n            end_time = row.end_time\r\n            \r\n            print(f\"Checking {row.canteen_name}: {start_time} - {end_time}\")\r\n            print(f\"Current event time: {event_time}\")\r\n            \r\n            # Dynamic time window check\r\n            if start_time <= event_time <= end_time:\r\n                eligible = True\r\n                trigger = (f\"Canteen: {row.canteen_name} \"\r\n                         f\"({start_time.strftime('%H:%M')} - {end_time.strftime('%H:%M')})\")\r\n                print(f\"Match found: {trigger}\")\r\n                break\r\n        \r\n        conn.close()\r\n        \r\n    except Exception as e:\r\n        print(\"Error checking canteen eligibility:\", e)\r\n        return False\r\n    \r\n    if eligible:\r\n        print(f\"Timing eligibility met based on {trigger}\")\r\n    else:\r\n        print(\"No eligible timing found\")\r\n    \r\n    return eligible\r\n\r\n###############################################\r\n# Row Count Change & Overall Eligibility Check\r\n###############################################\r\ndef row_count_change(table_name, previous_count, new_count):\r\n    \"\"\"\r\n    Triggered when a monitored table's row count changes.\r\n    \r\n    Retrieves the latest event from the MAIN_DB monitored table (TABLE_PREFIX + 6 digits).\r\n    Checks if the event's DEVUID is registered as a canteen device or an entry device.\r\n      - If canteen device: \r\n          * Checks canteen timing eligibility using check_elegibility().\r\n          * If eligible, retrieves the latest attendance event for the user.\r\n          * Computes allowed deadline = SHIFT_START_TIME + ATTENDANCE_BUFFER_MINUTES.\r\n          * If the attendance event occurred before the deadline, returns True; otherwise, False.\r\n      - If entry device: automatically eligible.\r\n      - Otherwise: automatically eligible.\r\n    \"\"\"\r\n    print(f\"Row count changed for {table_name}: from {previous_count} to {new_count}\")\r\n    config = current_app.config\r\n    host = config.get(\"MAIN_DB_HOST\")\r\n    username = config.get(\"MAIN_DB_USERNAME\")\r\n    password = config.get(\"MAIN_DB_PASSWORD\")\r\n    dbname = config.get(\"MAIN_DB_NAME\")\r\n    tz = pytz.timezone(config.get(\"TIME_ZONE\", \"UTC\"))\r\n    \r\n    conn_str = (\r\n        f\"DRIVER={{ODBC Driver 17 for SQL Server}};\"\r\n        f\"SERVER={host};\"\r\n        f\"DATABASE={dbname};\"\r\n        f\"UID={username};PWD={password}\"\r\n    )\r\n    \r\n    try:\r\n        conn = pyodbc.connect(conn_str, timeout=5)\r\n        cursor = conn.cursor()\r\n        query = f\"SELECT TOP 1 DEVDT, DEVUID, USRID FROM {table_name} ORDER BY SRVDT DESC\"\r\n        cursor.execute(query)\r\n        row = cursor.fetchone()\r\n        if row:\r\n            # Convert DEVDT if it's a Unix timestamp.\r\n            event_dt = row.DEVDT\r\n            if isinstance(event_dt, (int, float)):\r\n                event_dt = datetime.datetime.fromtimestamp(event_dt, tz=pytz.utc)\r\n            print(f\"Latest event in {table_name}: DEVDT={event_dt}, DEVUID={row.DEVUID}, USRID={row.USRID}\")\r\n            event_devid = str(row.DEVUID)\r\n            event_local = event_dt.astimezone(tz)\r\n            print(f\"Event local time: {event_local}\")\r\n            \r\n            # Retrieve dynamic device lists.\r\n            canteen_ids = get_canteen_device_ids()\r\n            entry_ids = get_entry_device_ids()\r\n            \r\n            if event_devid in canteen_ids:\r\n                print(\"Device is registered as a canteen device. Checking canteen eligibility...\")\r\n                if not check_elegibility(event_dt, row.DEVUID, row.USRID):\r\n                    print(\"Canteen timing conditions not met; not eligible.\")\r\n                    return False\r\n                else:\r\n                    print(\"Canteen timing conditions met.\")\r\n                    latest_entry = get_latest_entry_event_time(row.USRID)\r\n                    if latest_entry is None:\r\n                        print(\"No attendance event found; not eligible.\")\r\n                        return False\r\n                    shift_start_str = config.get(\"SHIFT_START_TIME\", \"01:00\")\r\n                    attendance_buffer = config.get(\"ATTENDANCE_BUFFER_MINUTES\", 60)\r\n                    try:\r\n                        shift_start_time = datetime.datetime.strptime(shift_start_str, \"%H:%M\").time()\r\n                    except Exception as e:\r\n                        print(\"Error parsing SHIFT_START_TIME:\", e)\r\n                        return False\r\n                    allowed_deadline = datetime.datetime.combine(event_local.date(), shift_start_time) + datetime.timedelta(minutes=attendance_buffer)\r\n                    allowed_deadline = tz.localize(allowed_deadline)\r\n                    print(f\"Allowed attendance deadline: {allowed_deadline}\")\r\n                    print(f\"Latest attendance event: {latest_entry}\")\r\n                    \r\n                    if latest_entry <= allowed_deadline:\r\n                        print(\"Attendance event is within allowed buffer; eligible for canteen service.\")\r\n                        return True\r\n                    else:\r\n                        print(\"Attendance event is too late; not eligible.\")\r\n                        return False\r\n            elif event_devid in entry_ids:\r\n                print(\"Device is registered as an entry device; automatically eligible.\")\r\n                return True\r\n            else:\r\n                print(\"Device not registered as canteen or entry; automatically eligible.\")\r\n                return True\r\n        else:\r\n            print(f\"No event details found in {table_name}.\")\r\n            return False\r\n        conn.close()\r\n    except Exception as e:\r\n        print(f\"Error retrieving event details from {table_name}: {e}\")\r\n        return False\r\n\r\n###############################################\r\n# Monitored Counts Table Update\r\n###############################################\r\ndef ensure_monitored_counts_table():\r\n    \"\"\"\r\n    Ensure that the monitored_table_counts table exists in LOGGER_DB.\r\n    This table stores the monitored table name, row count, and timestamp.\r\n    \"\"\"\r\n    conn = get_logger_db_conn()\r\n    cursor = conn.cursor()\r\n    create_table_sql = \"\"\"\r\n    IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'monitored_table_counts')\r\n    BEGIN\r\n        CREATE TABLE monitored_table_counts (\r\n            id INT IDENTITY(1,1) PRIMARY KEY,\r\n            table_name VARCHAR(100) NOT NULL,\r\n            row_count BIGINT NOT NULL,\r\n            updated_at DATETIME DEFAULT GETDATE()\r\n        );\r\n    END\r\n    \"\"\"\r\n    try:\r\n        cursor.execute(create_table_sql)\r\n        conn.commit()\r\n    except Exception as e:\r\n        print(\"Error ensuring monitored_table_counts table:\", e)\r\n    finally:\r\n        conn.close()\r\n\r\ndef update_monitored_table_counts():\r\n    \"\"\"\r\n    Retrieves monitored table row counts from MAIN_DB and saves them to LOGGER_DB.\r\n    Clears the monitored_table_counts table first, then inserts fresh data.\r\n    For any table with a changed row count (compared to the previous snapshot),\r\n    calls row_count_change() to process the event.\r\n    \"\"\"\r\n    global previous_monitored_counts\r\n    monitored_tables = get_main_db_monitored_tables()\r\n    if not monitored_tables:\r\n        print(\"No monitored tables data retrieved.\")\r\n        return {\"error\": \"No data retrieved\"}\r\n    \r\n    # Check for row count changes.\r\n    for entry in monitored_tables:\r\n        table_name = entry[\"table_name\"]\r\n        new_count = entry[\"row_count\"]\r\n        previous_count = previous_monitored_counts.get(table_name)\r\n        if previous_count is None or previous_count != new_count:\r\n            row_count_change(table_name, previous_count, new_count)\r\n    previous_monitored_counts = {entry[\"table_name\"]: entry[\"row_count\"] for entry in monitored_tables}\r\n    \r\n    ensure_monitored_counts_table()\r\n    conn = get_logger_db_conn()\r\n    cursor = conn.cursor()\r\n    try:\r\n        cursor.execute(\"DELETE FROM monitored_table_counts\")\r\n        insert_sql = \"\"\"\r\n            INSERT INTO monitored_table_counts (table_name, row_count)\r\n            VALUES (?, ?)\r\n        \"\"\"\r\n        for entry in monitored_tables:\r\n            cursor.execute(insert_sql, (entry[\"table_name\"], entry[\"row_count\"]))\r\n        conn.commit()\r\n        return {\"status\": \"success\", \"data\": monitored_tables}\r\n    except Exception as e:\r\n        print(\"Error updating monitored_table_counts:\", e)\r\n        return {\"error\": str(e)}\r\n    finally:\r\n        conn.close()\r\n\r\n###############################################\r\n# Route Endpoints\r\n###############################################\r\n@monitored_tables_bp.route('/monitored-tables', methods=['GET'])\r\ndef get_monitored_tables_route():\r\n    if not session.get('logged_in'):\r\n        return redirect(url_for('auth.login'))\r\n    monitored = get_main_db_monitored_tables()\r\n    return jsonify(monitored)\r\n\r\n@monitored_tables_bp.route('/update_monitored_counts', methods=['GET'])\r\ndef update_monitored_counts_route():\r\n    if not session.get('logged_in'):\r\n        return redirect(url_for('auth.login'))\r\n    result = update_monitored_table_counts()\r\n    return jsonify(result)"
        }
    ]
}